# 线性代数基础

## 基本知识

### 向量点乘

点乘定义：

![image-20250211145545731](./GAMES101.assets/image-20250211145545731.png)

点乘算法：

![image-20250211145622369](./GAMES101.assets/image-20250211145622369.png)

点乘的用法：同坐标轴相乘再相加，得到点乘值，再用定义求出夹角cos。

点乘的用途：判断两向量方向上的相似性。

![image-20250211145806953](./GAMES101.assets/image-20250211145806953.png)

### 向量叉乘

叉乘算法：向量形式

![image-20250211150526967](./GAMES101.assets/image-20250211150526967.png)

矩阵形式：

![image-20250211150609309](./GAMES101.assets/image-20250211150609309.png)

叉乘的用途：判定左右与内外

![image-20250211150651673](./GAMES101.assets/image-20250211150651673.png)

当a向量与b向量的叉积为正，说明b向量位于a向量的左侧，反之位于右侧。

![image-20250211150950138](./GAMES101.assets/image-20250211150950138.png)

如上图所示， **如何判断p点位于三角形内或是三角形外呢？**

将ABC三条边逆时针排列，分别作叉积。如AB叉乘AP，得到正向量，说明点P位于向量AB左侧，同理可判断点P位于BC、CA左侧，即可知点P位于三角形ABC内部。

**如果P点位于三角形外部，则一定有至少一个叉积不为正。**

顺时针同理，P点均位于三条向量的右侧。因此可得，P点如果位于三角形的内部，则他位于三条向量的同侧，叉积的符号相同。

### 矩阵

矩阵乘法

![image-20250211153439316](./GAMES101.assets/image-20250211153439316.png)

点乘与叉乘的矩阵形式：

![image-20250211154219914](./GAMES101.assets/image-20250211154219914.png)

点乘很好理解，叉乘需要将a向量组织为图示的A矩阵，再与b向量相乘。

## 变换Transformation

### 仿射变换Affine Transformation

仿射变换是两种简单变换的叠加，即线性变换与平移变换。

#### 缩放变换Scale

 ![image-20250211160716214](./GAMES101.assets/image-20250211160716214.png)

#### 反射变换Refelction

![image-20250211161004528](./GAMES101.assets/image-20250211161004528.png)

#### 斜切变换Shear

![image-20250211161408958](./GAMES101.assets/image-20250211161408958.png)

#### 旋转变换Rotate

![image-20250211161728727](./GAMES101.assets/image-20250211161728727.png)

#### 平移变换Translation

![image-20250211162700947](./GAMES101.assets/image-20250211162700947.png)

无法写成矩阵形式！平移变换不属于线性变换的范畴。因而引入齐次坐标的概念：

![image-20250211163519250](./GAMES101.assets/image-20250211163519250.png)

以二维坐标系为例，加入了新的一个维度。**对于点，第三个维度表示为1，对于向量，第三个维度表示为0。**

当我们需要表示点的平移变换时，只需像上图所示，在变换矩阵的第三列加入tx和ty平移参数，得到的结果就是经过平移的点。

**然而，向量是具有平移不变性的**，因此向量的第三个维度表示为0，无论在变换矩阵的第三列加入什么平移参数，都不会影响变换后得到的向量。

 引入齐次坐标后的加减意义：

![image-20250211164544317](./GAMES101.assets/image-20250211164544317.png)

针对点加点的形式，齐次坐标也给出了扩充定义，即表示第三坐标归一化后的点。如果两点的齐次坐标相加，得到的新点即是两点的中点。

**需要再次强调的是，我们在图形学中引入齐次坐标的概念，目的是为了将所有的简单变换统一表示成线性变换的形式，即一个矩阵乘以一个向量的形式。**

![image-20250211164925705](./GAMES101.assets/image-20250211164925705.png)

#### 齐次坐标下的仿射变换

![image-20250211164953735](./GAMES101.assets/image-20250211164953735.png) 

以任意点为中心的旋转问题：

![image-20250211171638985](./GAMES101.assets/image-20250211171638985.png)

利用矩阵的结合律，先把需要围绕旋转的指定点平移至原点位置，绕原点进行旋转，随后再平移回去，矩阵形式表示如上。

值得注意的是，矩阵乘法是从右向左应用的：

![image-20250211171334615](./GAMES101.assets/image-20250211171334615.png)

### 观测变换Viewing Transformation

#### 视图变换View

 如何唯一确定相机的位置和观测方向？

![image-20250212160131972](./GAMES101.assets/image-20250212160131972.png)

三个参数：位置，朝向，向上方向。

当相机和物体的相对位置不变，得到的图像也不会变。因此为了方便计算，定义相机放置的位置为原点，观测的方向为-z，向上方向为y，称为标准位置。

把相机变换至标准位置的矩阵推导如下：

![image-20250212161045099](./GAMES101.assets/image-20250212161045099.png)

首先进行平移操作，随后进行旋转。由于旋转矩阵具有正交的性质，因此可以先求出逆变换矩阵，再转置，即可得到变换矩阵。

对坐标系中的所有物体应用变换矩阵，即可完成视图变换，得到相机位于标准位置的坐标系。

#### 投影变换Projection

投影变换通常是图形学的最后一步，将3D建模转换为2D图像。

![image-20250212162011570](./GAMES101.assets/image-20250212162011570.png)

正交投影与透视投影，透视投影的光线会聚于一点，正交投影假设相机无限远，光线全部平行。

##### 正交投影Orthographic Projection

定义空间中的一个立方体，使用六个数字来表示。将其中心位移至原点，再变换为「Canonical Cube」，变换矩阵如下

![image-20250212163424280](./GAMES101.assets/image-20250212163424280.png)

top，bottom，left，right，near，far

##### 透视投影Perspective Projection

基本思路：将透视投影转换为正交投影

![image-20250212175245697](./GAMES101.assets/image-20250212175245697.png)

视锥Frustum

规定近平面near永远不变，以近平面为基准进行收缩远平面far，且中心点不变

![image-20250212180111861](./GAMES101.assets/image-20250212180111861.png)

从侧面观察Frustum，可以发现从原点出发，n平面与f平面形成了相似三角形！

因此以y轴为例，可以得到n平面与f平面的y坐标的关系如上，由此可以得到压缩后的坐标：

![image-20250212180257315](./GAMES101.assets/image-20250212180257315.png)

可以观察到，得到的新坐标x和y均有一个z做分母，因此可以把四个坐标值全部乘z，前面已经提到在齐次坐标中，一个点乘以任意一个数值，表示的还是该点。

由此得到部分的由透视转为正交的转换矩阵：

![image-20250212180658035](./GAMES101.assets/image-20250212180658035.png)

最后再来推导矩阵的z行：

首先明确，对于位于近平面和远平面的点，经过变换后z坐标都不会发生变化。

对于近平面，有如下变换：

![image-20250212180933719](./GAMES101.assets/image-20250212180933719.png)

从n变为n^2，说明变换矩阵的第三行不与x和y发生任何关系，由此可以得到矩阵的第三行的部分形式：

![image-20250212181023237](./GAMES101.assets/image-20250212181023237.png)

对于远平面，取远平面的中心点（x，y为0）有如下变换：

 ![image-20250212181448499](./GAMES101.assets/image-20250212181448499.png)

同时，上一步中我们也得到了一个关系式：

![image-20250212181603432](./GAMES101.assets/image-20250212181603432.png)

解得A与B：

![image-20250212181730542](./GAMES101.assets/image-20250212181730542.png)

## 光栅化Rasterization

变换结束后，所有的物体都被变换至标准立方体内，下一步就是将其显示在屏幕上，也就是光栅化的任务。

首先需要明确两个概念：fov与长宽比

![image-20250213142256869](./GAMES101.assets/image-20250213142256869.png)

fov和长宽比可以使用lrbt表示：

![image-20250213142500496](./GAMES101.assets/image-20250213142500496.png)

定义屏幕像素坐标系：屏幕左下角为原点，向右为x，向上为y，使用一组整数来确定一个像素的位置。

 将标准立方体变换至屏幕范围：

![image-20250213143617395](./GAMES101.assets/image-20250213143617395.png)

与z无关，x和y各拉伸二分之长或宽，随后平移左下角至原点，变换矩阵如上。

### 采样Sampling

以像素中心点为基准进行采样，得到整个像素的值

![image-20250213150059503](./GAMES101.assets/image-20250213150059503.png)

inside函数，当中心点位于三角形内时，函数值为1，否则为0。代码表示如下：

![image-20250213150325153](./GAMES101.assets/image-20250213150325153.png)

![image-20250213150134356](./GAMES101.assets/image-20250213150134356.png)

采样会产生一个问题，就是锯齿，因此需要反走样与抗锯齿技术：

### 反走样Antialiasing

如何减少走样现象？

要解决问题，首先需要了解信号采样的原理：在时域上进行采样，等于在频域上进行频谱的复制和搬移；在时域上进行卷积，等于在频域上相乘。

![image-20250213184304960](./GAMES101.assets/image-20250213184304960.png)

走样现象其实就是频谱在搬移过程中，产生了混叠。

![image-20250213184327803](./GAMES101.assets/image-20250213184327803.png)

在时域上采样越密集，频域上频谱的搬移越稀疏，因此只需要增加采样率，就能减少频域上的混叠现象（采样定理）。然而增加采样率显然会导致成本的上升。

在采样前进行滤波，使图像变得模糊，再进行采样： 

![image-20250213174424096](./GAMES101.assets/image-20250213174424096.png)

这实际上是消除了一部分图像的高频信息，从频域的角度理解如下：

![image-20250213184626466](./GAMES101.assets/image-20250213184626466.png)

同样的采样率，当我们消除了原本频谱的高频段，再进行频谱的搬移，就可以避免发生混叠。

具体的步骤如下：先使用一个卷积核，对每一个像素进行卷积，随后再取样每个像素的中心点。而最简单的卷积核就是1x1的像素块，只需要对每个块内取均值即可：

![image-20250213185150603](./GAMES101.assets/image-20250213185150603.png)

但这样的采样计算量非常大（计算面积）！

#### 多重采样反走样MSAA

将每一个像素划分为点阵，对每个点进行采样取平均，即可得到滤波后的值：

![image-20250213185537615](./GAMES101.assets/image-20250213185537615.png)

图示为2x2超采样。以上顶点为例，一个像素的四个取样点中，三个取样点被覆盖，因此该像素点具有75%的强度。

![image-20250213185631234](./GAMES101.assets/image-20250213185631234.png)

### 深度缓存Z-Buffer

经过上述步骤，我们已经可以完成单个三角形的变换和光栅化了。然而，当需要渲染的三角形多于一个，就需要考虑他们在空间中的覆盖关系。

画家算法：从最远端的三角形开始逐个渲染，直至最近的三角形，新渲染的三角形会覆盖掉旧的。

然而，并非所有的三角形都存在绝对的覆盖关系：

![image-20250214172422795](./GAMES101.assets/image-20250214172422795.png)

上图中的三个三角形，两两覆盖，无论是怎样的渲染顺序都无法正确渲染出这幅图片的覆盖关系。

因此想到减小渲染的单位，把三角形分为像素点来考虑：

![image-20250214154107760](./GAMES101.assets/image-20250214154107760.png)

维护深度缓存矩阵，遍历每个三角形的每个像素，查看其z轴信息，记录最近的深度，复杂度O(n)

## 着色Shading

对不同的物体应用不同的材质的过程，即为着色。不同材质对光线有着不同的反射效果。

首先定义着色中有关光线反射的几个概念：

- 视角方向v
- 平面法线n
- 光源方向l
- 平面参数（颜色，光泽度等）

![image-20250215160620149](./GAMES101.assets/image-20250215160620149.png)

值得注意的是，着色是局部问题，也就是说我们只关心要着色的像素的光照反射情况。这也意味着着色是不会生成阴影等光学现象的！

![image-20250215161308688](./GAMES101.assets/image-20250215161308688.png)

光线打到物体表面，如何确定反射的亮度？需要考虑以下几个方面：

入射角度，单位面积光照能量与入射角度cos值呈正比

![image-20250215162505780](./GAMES101.assets/image-20250215162505780.png)

距离衰减，与距离的平方成反比（球面积）

![image-20250215162543896](./GAMES101.assets/image-20250215162543896.png)

以及物体表面固有的属性，如颜色属性，白色的物体反射所有的光线，绿色的物体反射绿色的光线，黑色的物体吸收所有光线。以（R，G，B）三基色为例，直接将物体的颜色权值乘以光照强度，就能得到反射光线的颜色和分别的强度。

由以上三点，即可以推导出一个简单的光照模型：Blinn-Phong 光照模型。

### Blinn-Phong Reflectance Model

该光照模型包含三大部分：漫反射、镜面反射、环境光照。三种光照相加，即得到物体的着色信息。

漫反射的特点是，从各个方向看到的光照强度是不变的（同向的前提下）。

![image-20250215163004021](./GAMES101.assets/image-20250215163004021.png)

漫反射的强度公式由上图给出，其中kd表示表面的颜色属性，（I/r^2）表示光线距离衰减，n点乘l表示入射角，max函数用于排除掉反面观测的情况。

应用漫反射的着色效果如下：

![image-20250215165832609](./GAMES101.assets/image-20250215165832609.png)

镜面反射的特点是，只有视角在出射光线角度附近时，才能接收到光线能量。如下图所示，出射光线R与视角v角度相近。

![image-20250215170023850](./GAMES101.assets/image-20250215170023850.png)

在BP模型中，对此特点做了简化：

![image-20250215170447581](./GAMES101.assets/image-20250215170447581.png)

将光线方向l和视角方向v两个向量相加，即可得到两者之间中心的方向，称为半程向量h。半程向量的求解非常简单，且只需判断平面法线与半程向量的夹角a。

值得注意的是，式子中的p次方可以调整，根据cos次方的变化：

![image-20250215174546729](./GAMES101.assets/image-20250215174546729.png)

通过调整p的数值，可以实现镜面反射光线可视角度的变化。

效果如下：

![image-20250215174753040](./GAMES101.assets/image-20250215174753040.png)

环境光照的表示很简单，光照强度乘以表面系数即可。

![image-20250215175146389](./GAMES101.assets/image-20250215175146389.png)

值得指出的是，BP模型中的环境光照只是一个简单的模拟，并不真实。

三者结合后的效果如下：

![image-20250215175718146](./GAMES101.assets/image-20250215175718146.png)

### 着色频率Shading Frequencies

上述着色过程指的是对一个点或一个面的着色流程，而对于整个物体来说，着色的效果如何还要取决于着色频率。

![image-20250218140239099](./GAMES101.assets/image-20250218140239099.png)

上图中三种不同效果，分别代表了三种不同的着色频率：

平面着色，以三角形为单位着色，每个三角形平面确定一个法线，以法线为基准进行着色。

![image-20250218140628816](./GAMES101.assets/image-20250218140628816.png)

顶点着色，每个平面相交的顶点处确定一条法线，对该法线计算着色，两顶点间平均着色。

![image-20250218140726022](./GAMES101.assets/image-20250218140726022.png)

像素着色，对每像素计算着色。效果最好，计算量较大。

![image-20250218143432708](./GAMES101.assets/image-20250218143432708.png)

三种着色方式的对比：

![image-20250218143707524](./GAMES101.assets/image-20250218143707524.png)

可以看出，建模平面量的多少决定了前两种着色方式的效果，但对像素着色无影响。

### 着色管线

